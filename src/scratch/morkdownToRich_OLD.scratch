import Discord from "discord.js";
import marked, { Tokenizer, Token } from "marked";
import { decode } from "he";
import { markdown as mark, unmark } from "../utils";

import util from "util";

// const NP_SPACE = "â€‹";

interface List {
  counter: number;
  accumulator: string[];
}

export default function (markdown: string): Discord.MessageEmbed {
  const message = new Discord.MessageEmbed();
  let currentToken: Token;
  let inDescription = true;
  let inBlockQuote = false;

  let list: List = {
    counter: 0,
    accumulator: [],
  };

  const append = (text: string) => {
    if (!text) return;

    if (inDescription) {
      if (!message.description) {
        message.description = decode(text);
      } else {
        message.description += decode(text);
      }
    } else {
      if (message.fields.length) {
        message.fields[message.fields.length - 1].value += decode(text);
      } else {
        throw new Error("You're not yet in Field scope!");
      }
    }
  };

  const truncateIfNeeded = () => {
    while (message.length > 2000) {
      if (message.fields.length) {
        message.fields.pop();
      } else {
        message.description = message.description?.slice(0, 1800) ?? "";
      }
    }
  };

  marked.use({
    tokenizer: new Tokenizer({ mangle: false }),
    // @ts-ignore
    walkTokens: (token: Token) => {
      // @ts-ignore
      if (token.type === "blockquote") {
        inBlockQuote = true;
        // @ts-ignore
        token.text = "";
        token.raw = "";
      }
      currentToken = token;
      // @ts-ignore
      // console.log(token.type)
    },
    renderer: {
      options: {},
      code: (code, language, isEscaped) => {
        void language, isEscaped;
        append(`\`\`\`${language}\n${code}\`\`\``);
        return "";
      },

      blockquote: (quote) => {
        // if (quote.startsWith("How")) console.log("RENDER BLOCKQUOTE");
        append(`> ${quote}\n\n`);
        inBlockQuote = false;
        return `> ${quote}\n\n`;
      },

      html: (html) => {
        // TODO
        return html;
      },

      heading: (text, level, raw, slugger) => {
        void slugger, raw;
        if (level === 1) {
          message.setTitle(text);
        } else {
          // content += `\n\n**${text}**\n\n`;
          inDescription = false;
          message.fields.push({ name: text, value: "", inline: false });
        }
        return raw;
      },

      hr: () => {
        // TODO
        append("---\n\n");
        return "\n---\n";
      },

      list: (body, ordered, start) => {
        void body, ordered, start;
        // TODO
        append(
          mark(
            list.accumulator
              .map((item) => `${ordered ? `${++list.counter}.` : "-"} ${item}`)
              .join("\n")
          ) + "\n"
        );
        list.accumulator = [];
        list.counter = 0;
        // inDescription = false;
        // message.fields.push({ name: text, value: "", inline: false });
        return "";
      },

      listitem: (text) => {
        // TODO
        list.accumulator.push(text);
        return "";
      },

      checkbox: (checked) => {
        // TODO
        return checked ? "[x] " : "[ ] ";
      },

      paragraph: (text) => {
        // TODO
        // content += text;
        // if (text.startsWith("How")) console.log("RENDER PARAGRAPH");
        // if (!inBlockQuote) append(`${text}\n\n`);
        append(`${text}\n\n`);
        return text;
      },

      table: (header, body) => {
        // TODO
        return `${header}|${body}`;
      },

      tablerow: (content) => {
        // TODO
        return content;
      },

      tablecell: (content, flags) => {
        // TODO
        void flags;
        return content;
      },

      // INLINE
      strong: (text) => {
        return `**${text}**`;
      },

      // INLINE
      em: (text) => {
        return `*${text}*`;
      },

      // INLINE
      codespan: (code) => {
        // append(`\`${code}\``);
        return `\`${code}\``;
      },

      // INLINE
      br: () => {
        return "\n";
      },

      // INLINE
      del: (text) => {
        // append(`~~${text}~~`);
        return `~~${text}~~`;
      },

      // INLINE
      link: (href, title, text) => {
        void title;
        // append(`[${text?? ""}](${href})`);
        return `[${text ?? ""}](${href})`;
      },

      // INLINE -- TEST THIS?
      image: (href, title, text) => {
        void title, text;
        message.image = { url: href ?? "" };
        return text;
      },

      // INLINE
      text: (text) => {
        // if (text.startsWith("How")) console.log("RENDER TEXT");
        // TODO: Figure out how to append regular text to the doc, but still pass content of other tags back to it's handler
        // append(text);
        return text;
      },
    },
  });

  try {
    marked(unmark(markdown));
  } catch (e) {
    console.error(e);
  }

  message.setColor("DARK_ORANGE");
  truncateIfNeeded();
  return message;
}
